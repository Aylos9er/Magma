#!/usr/bin/env python
""" 
..  module:: examples
    :platform: Unix, Windows
..  moduleauthor: Jess Robertson, CSIRO Earth Science and Resource Engineering

    :synopsis: Simple example use cases for pymelts MELTS bindings.

    If you want to shift this script somewhere else, make sure that you keep 
    the data folder with it or things will break. You probably also want to 
    make sure that you've installed the pymelts package (do `python setup.py 
    install` in the directory above this one) so that it's available on 
    your preferred version of Python.
"""

import pymelts
import matplotlib.pyplot
from pymelts.utilities import cycle_cmap, celsius

def calling_melts_engine():
    """ Example 1: This is more or less a rewrite of test_dynamiclib.f in 
                   Python
    """
    # Get oxide and phase names
    engine = pymelts.Engine()
    print engine.get_oxide_names()
    print engine.get_phase_names()

    # Make a new MELTS calculation
    melt = pymelts.Melt(
        composition=pymelts.Composition(
            SiO2=48.68, TiO2=1.01, Al2O3=17.64, Fe2O3=0.89, 
            Cr2O3=0.0425, FeO=7.59, MnO=0.0, MgO=9.10, 
            CaO=12.45, Na2O=2.65, K2O=0.03, P2O5=0.08, H2O=0.2),
        temperature=1400., 
        pressure=1000.,
        mode='ptx',
        solve=True)
    print melt.status
    print melt.properties

    # Example of a continuation call with changing enthalpy
    melt.set_mode('phx')
    results_string = ("System: P = {0.pressure:9.2g} kPa, "
        + "H = {0.enthalpy:9.2g} J, "
        + "T = {0.temperature:9.2g} deg C\n")
    output = ""
    for i in range(1, 10):
        melt.enthalpy -= 1000.
        melt.solve()
        output += results_string.format(melt)
    
    print output

def generate_new_data():
    """ Example 3: Use a config file to generate solutions for varying 
                   temperature by calling MELTS directly.

        Calling the melts engine to generate a new temperature-varying dataset 
        from MELTS
    """
    # Read in the configuration file, generate MeltCollection
    fpath = 'data/komatiite/komatiite.melts'
    config_file = pymelts.readers.read_config_file(fpath)
    print config_file
    collection = pymelts.MeltCollection(
        solve=True,
        mode='ptx',
        temperature=(1500, 1250, 25),
        pressure=100,
        composition=config_file['composition'])
    

    # Set the colors in the axes to something more useful (cycle_cmap is 
    # imported from `pymelts.utilities`), we'll set this using 
    # axes.set_color_cycle in the loop below.
    cmap = cycle_cmap('Spectral', len(reader.phases))

    # Loop through MeltCollection and pull out data
    temp_data = []
    y_variables = ['mass', 'specific heat', 'density']
    y_data = dict([(var, []) for var in y_variables])
    all_data = defaultdict(y_data)
    for melt in collection:
        x_data.append(melt.temperature)
        for phase in melt.phases:
            for var in y_variables:
                all_data[phase][y_variable].append(melt[phase][y_variable])

    print all_data

    # # Specify the variables to plot and some labels for axes
    x_axis_label = r'Temperature ($^{\circ}\mathrm{C}$)'
    y_variable_labels = dict(zip(y_variables, [
        r'Mass ($m$, $g$)', 
        r'Specific heat ($c_{p}$, J kg$^{-1}$ K$^{-1}$)', 
        r'Density ($\rho$, kg m$^{-3}$) ']))

    # Generate plots
    nrows, ncols = len(y_variables), 1
    fig = matplotlib.pyplot.figure(figsize=(6, 3*nrows))
    for nax, y_variable in enumerate(y_variables):
        # Get the matplotlib axes instance we want to plot in
        axs = matplotlib.pyplot.subplot(nrows, ncols, nax+1)
        axs.set_color_cycle(cmap)

        # Loop through the phases which are present
        for phase in reader.phases:
            # Plot data - we use the temperature in the phase_data attribute 
            # since the phase may not be present for all of the temperatures 
            # specified in the system_data['temperature'] data.
            axs.plot(
                celsius(reader.phase_data[phase][x_variable]), 
                reader.phase_data[phase][y_variable], 
                label=phase)

    #         # Annotate the plot
    #         if nax == 0:
    #             axs.legend(loc='best', prop={"size":10})
    #         axs.set_ylabel(y_variable_labels[y_variable])

    # # Add an x axis label on the bottom plot only
    # axs.set_xlabel(x_axis_label)
    # fig.suptitle('Physical Properties of Phases in Komatiite' + 
    #     '\n(as calculated by MELTS)')

    # # Save figure to testing folder as pdf.
    # fig.savefig('komatiite.pdf')

def read_existing_data():
    """ Example 1: Read existing data from standalone engine, plot changes in 
                   phases with temperature

        This example shows how to use the data parser class `Reader` 
        (in `pymelts.readers`) to read in an entire folder of MELTS data which 
        has already been generated by the standalone solver. The data is read 
        into a variety of attributes in the returned Reader instance:

        - `Reader.folder` - the location of the MELTS output folder.

        - `Reader.files` - a dictionary containing the files which Reader 
                has identified in the folder. This can be useful if you want 
                to make sure that it is identifying the correct output files.

        - `Reader.config_data` - a dictionary containing the information about the MELTS parameters used to drive the MELTS simulation.

        - `Reader.system_data` - a dictionary containing the information about 
                the extensive system variables (temperature, pressure, 
                fugacities etc). Note that temperature is specified in Kelvin;
                use the celsius function from pymelts.utilities to change this
                to degrees Celsius.

        - `Reader.phases` - contains a list of major phases in the magma

        - `Reader.endmembers` - contains a dictionary of the phases 
                present in the MELTS simulation, where each key is a phase and 
                each value is a list of the endmember phases for that phase

        - `Reader.phase_data` - contains the data from MELTS for a given phase.
                This attribute is a dictionary whose keys are given by Reader.
                phases, and whose values are dictionaries which contain 
                physical properties (e.g. density, specific heat, viscosity) 
                and proportions of endmember phases.

        This uses this data to generate plots of phase properties in a magma 
        with varying temperature. The plots are stored as PDFs in the same 
        folder you've run this script from. You can see that using the Reader 
        instance's attributes it's fairly easy to iterate over the data which 
        are available in the in a composition/magma agnostic fashion. You can 
        also change which variables are plotted by changing the plot_vars 
        variable.

        Because reading and parsing the data can be fairly time-consuming, the 
        `Reader` class implements a basic form of caching by writing the 
        initialised `Reader` instance out in binary format into the folder (in 
        a file called `<folder_name>.pkl`). On subsequent reads of the folder, 
        the `Reader` class checks for a pickled version of the data & loads it 
        directly if it's there.

        You can force a refresh of the data (i.e. by reparsing it) by setting 
        '`force=True`' when you initialise a reader instance. This will 
        overwrite the existing binary file with the new data.
    """
    pass

def main():
    """ Run all examples
    """
    # calling_melts_engine()
    generate_new_data()

if __name__ == '__main__':
    main()