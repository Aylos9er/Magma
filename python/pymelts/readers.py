#!/usr/bin/env python
""" file: readers.py
    author: Mark S. Ghiorso (original: Jess Robertson, CSIRO Earth Science and Resource Engineering)
    date: August 31, 2016

    description: Some functions to read in a MELTS output folder and make it 
        available to Python. The functions here are designed for a MELTS run 
        which has already been done with the standalone MELTS solver, and
        all you want to do is read in the data.
"""

import re
import os
import numpy
import csv
import cPickle as pickle
import fnmatch
from collections import defaultdict 
from composition import Composition
from melt import Melt, MeltCollection
from utilities import celsius, kelvin

def read_config_file(filename):
    """ Reads and parses a MELTS input file.

        input:
            filename - the path pointing to a MELTS file.

        Returns:
            a dictionary with the following keys and values:
                'temperature' - a tuple containing (Ti, Tf, dT), where Ti is the initial temperature, Tf the final temperature and dT the temperature step
                'pressure' - a tuple containing (Pi, Pf, dP), where Pi is the initial pressure, Pf the final pressure and dP the pressure step
                'composition' - a Composition instance containing the composition in 
                    the file.
                'state' - a dictionary containing the oxidation state (under the 'oxidation' key) and pressure-temperature gradient (under 'dp/dt') if specified in the file).
                'extras' - a list of strings containing other lines not included above that this function doesn't know how to handle.
    """
    # Make results dictionary to store config infomation
    result = {}
    result['extras'] = []
    result['state'] = {'oxidation': None, 'dp/dt': None}
    result['composition'] = Composition()
    result['temperature'], result['pressure'] = [0, 0, 0], [0, 0, 0]

    # Scroll through file, append results to the right places
    with open(filename, 'r') as fhandle:
        for line in fhandle:
            if line.startswith('Initial Composition'):
                key, value = line.split()[2:]
                result['composition'][key] = float(value)
            elif line.startswith('Initial Temperature'):
                result['temperature'][0] = float(line.split()[-1])
            elif line.startswith('Final Temperature'):
                result['temperature'][1] = float(line.split()[-1])
            elif line.startswith('Increment Temperature'):
                result['temperature'][2] = float(line.split()[-1])
            elif line.startswith('Initial Pressure'):
                result['pressure'][0] = float(line.split()[-1])
            elif line.startswith('Final Pressure'):
                result['pressure'][1] = float(line.split()[-1])
            elif line.startswith('Increment Pressure'):
                result['pressure'][2] = float(line.split()[-1])
            elif line.startswith('log fo2'):
                result['state']['oxidation'] = line
            elif line.startswith('dp/dt'):
                result['state']['dp/dt'] = float(line.split()[-1])
            else:
                result['extras'].append(line)

    # Convert some lists to tuples
    result['temperature']= tuple(result['temperature'])
    result['pressure']= tuple(result['pressure'])
    return result

class Reader(object):

    """ Reads in all the data from a folder containing MELTS output.

        On initialisation, a Reader instance will search the folder for the following default files, which it assumes match the expression in brackets:

            1.  a config file (`<something>.melts`) which contains the information used to generate the melts files.
            2.  an output file (`melts.out`) which contains the log generated by MELTS during execution.
            3.  a liquid phase file (`melts-liquid.tbl`) which contains the information about the liquid component of the magma.
            4.  a number of solid phase files (`<something>.tbl`)

        Note that if you have other files with the .tbl extension then Reader will try to read them. You are best to have a folder which _only_ contains the output from MELTS as this will be least likely to confuse your Reader instance.

        Reader then reads in all the data into a set of dictionaries which are stored in the phase_data attribute. Each key of the phase_data dictionary is a phase, and each value is another dictionary, whose keys are the names of physical properties, (or phase endmembers) and whose values are numpy arrays corresponding to the arrays in the system variables.

        The first time this is called Python might take a while to parse \ all the files, depending on how large they are. However it will serialise the information in the folder to a pickle file (called foldername.pkl) which will be much faster to load on subsequent calls.

        Some relevant attributes after initialisation are:

        - `folder`: the location of the MELTS output folder.

        - `files`: a dictionary containing the files which Reader has identified in the folder. This can be useful if you want to make sure that it is identifying the correct output files.

        - `config_data`: a dictionary containing the information about the MELTS parameters used to drive the MELTS simulation.

        - `data`: a pymelts.MeltCollection instance which stores the data from the folder.

        For more information, see the :py:class:`pymelts.MeltCollection` class.

        Arguments:
            melts_folder - a string giving the location of the MELTS output folder.
            force - if this flag is set, force an update of the MELTS data, don't just read in from the pickled version 
    """

    # These are the files which should be in the MELTS output folder. 
    melts_files = {
        'config': re.compile(r'.*\.melts$'),
        'output': re.compile(r'melts\.out$'),
        'liquid': re.compile(r'melts-liquid\.tbl$'),
        'phases': re.compile(r'.*\.tbl$')
    }

    # These are the regexes for parsing the MELTS output file for 
    # information. The first member of the tuple is a prefix for the 
    # properties, the second member lists the keys which are matched in 
    # the group, and the third member of the tuple is the regex which 
    # actually does the matching. 
    melts_out_info = [
        (
            '', 
            ['temperature', 'pressure', 'oxygen_fugacity'], 
            re.compile(r"""
                .* # Ignore guff to start with
                (?<=T\s\=\s) # Temperature starts with 'T...'
                    (?P<temperature>-?\d*\.?\d*) # Temperature value
                .* 
                (?<=P\s\=\s) # Pressure starts with 'P...'
                    (?P<pressure>\d*\.?\d*) # Pressure value
                .* 
                (?<=log\(10\)\sf\sO2\s=\s) # Oxygen fugacity starts with 'log(10) f O2'
                    (?P<oxygen_fugacity>-?\d*\.?\d*) # Oxygen fugacity value
                """, re.VERBOSE)
        ),
        (
            'liquid_',
            ['mass', 'density', 'viscosity', 'specific_heat'],
            re.compile(r"""
                \s*Liquid
                \s*(?<=mass\s\=\s)(?P<mass>-?\d*\.?\d*)
                .*(?<=density\s\=\s)(?P<density>-?\d*\.?\d*)
                .*(?<=viscosity\s\=\s)(?P<viscosity>-?\d*\.?\d*)
                .*(?<=Cp\s\=\s)(?P<specific_heat>-?\d*\.?\d*)
                """, re.VERBOSE)
        ),
        (
            'total_solids_',
            ['mass', 'density', 'specific_heat'],
            re.compile(r"""
                ^\s*Total\sSolids
                \s*(?<=mass\s\=\s)(?P<mass>-?\d*\.?\d*)
                .*(?<=density\s\=\s)(?P<density>-?\d*\.?\d*)
                .*(?<=Cp\s\=\s)(?P<specific_heat>-?\d*\.?\d*)
                """, re.VERBOSE)
        ),
        (
            'system_',
            ['mass', 'density', 'specific_heat'],
            re.compile(r"""
                ^\s*System
                \w*(?<=mass\s\=\s)(?P<mass>-?\d*\.?\d*)
                .*(?<=density\s\=\s)(?P<density>-?\d*\.?\d*)
                .*(?<=Cp\s\=\s)(?P<specific_heat>-?\d*\.?\d*)
                """, re.VERBOSE)
        )
    ]

    def __init__(self, melts_folder, force=False):
        super(Reader, self).__init__()
        self.folder = melts_folder
        filelist = os.listdir(self.folder)

        # Check for a previous pickled version of the folder, if it's there 
        # then load it - will be called folder.pkl
        picklename = os.path.basename(self.folder) + '.pkl'
        picklepath = os.path.join(self.folder, picklename)
        #if force is False and picklename in filelist:
        #    with open(picklepath, 'rb') as pfile:
        #        self.__dict__ = pickle.load(pfile)
        #        return # We can short out the parsing step now

        # Check whether the supplied folder is actually a MELTS output folder -
        # there will always be a melts-liquid.tbl file in the folder.
        # Changed order as it's possible the individual files may be cleaned
        # out once the .pkl file has been written
        files_in_folder = os.listdir(melts_folder)
        if fnmatch.filter(files_in_folder, 'melts-liquid.tbl') is []:
            raise IOError(('I couldn\'t find {1} in {0}. Is {0} really a MELTS'
                + ' output folder?').format(melts_folder, 'melts-liquid.tbl'))
            
        # Seperate files out from folder
        self.files = defaultdict(list)
        for fname in filelist:
            for key, regex in self.melts_files.iteritems():
                if regex.match(fname):
                    self.files[key].append(os.path.join(melts_folder, fname))

        # Fix up some of the entries
        self.files['output'] = self.files['output'][0]
        self.files['config'] = self.files['config'][0]
        self.files['liquid'] = self.files['liquid'][0]
        self.files['phases'].remove(self.files['liquid'])

        # Get a list of the phase names
        phase_names_regex = re.compile(r'(\w*)\.tbl$')
        self.phases = [phase_names_regex.search(s).groups()[0]
            for s in self.files['phases']] + ['liquid']

        # Read in file data
        self.config_data = self.read_config_file()
        self.system_data = self.read_output_file()

        # Read in solid phase data
        self.phase_data = defaultdict(list)
        self.endmembers = defaultdict(list)
        for phasename, phasefile in zip(self.phases, self.files['phases']):
            self.phase_data[phasename] = self.read_phase_file(
                    phasefile,
                    translation={
                        'temperature': 'T (C)',
                        'mass': 'mass (gm)',
                        'density': 'rho (gm/cc)',
                        'volume': 'V (cc)',
                        'specific heat': 'Cp (J/K)',
                    }, 
                    with_endmembers=True,
                    with_composition=True)
            self.endmembers[phasename] = self.phase_data['endmembers']

        # Read in liquid phase data
        self.phase_data['liquid'] = \
            self.read_phase_file(
                self.files['liquid'],
                translation={
                    'temperature': 'T (C)',
                    'log viscosity': 'liq vis (log 10 poise)',
                    'mass': 'liq mass (gm)',
                    'density': 'liq rho (gm/cc)',
                    'specific heat': 'liq Cp (J/K)'
                },
                with_endmembers=False,
                with_composition=True)

        # Pickle self to file for later loading
        with open(picklepath, 'wb') as pfile:
            pickle.dump(self.__dict__, pfile)

    def read_config_file(self):
        """ This method parses and stores the total system data in a MELTS 
            output file (whose filename is given in self.melts_file['output']).

            Returns:
            A dictionary of data used to set up the MELTS routine
        """
        # Loop through file, put data where it should go
        config_data = {'initial composition': Composition()}
        with file(self.files['config'], 'rb') as fhandle:
            for line in fhandle:
                key, value = line.split(':')
                key = key.strip().lower()
                if 'composition' in key:
                    # Plonk composition values in their own dictionary
                    species, concentration = value.strip().split(' ')
                    config_data[key][species] = float(concentration)
                else:
                    try:
                        config_data[key] = float(value)
                    except ValueError: 
                        # We've had an error coercing from float, so we'd best 
                        # just leave it alone & store as a string
                        config_data[key] = value.strip()
        return config_data

    def read_output_file(self):
        """ This method parses and stores the total system data in a MELTS output file (whose filename is given in `self.melts_file['output']`).

            Returns:
            A dictionary of data, which contains the system parameters (pressure, temperature, oxygen fugacity etc) as well as total amounts of solid etc.
        """
        # Actually parse the file using the regexes in self.melts_out_info
        output_data = defaultdict(list)
        with file(self.files['output'], 'rb') as fhandle:
            for line in fhandle:
                for prefix, keylist, regex in self.melts_out_info:
                    match = regex.search(line)
                    if match is not None:
                        for key in keylist:
                            output_data[prefix + key].append(
                                float(match.group(key)))
        
        # Convert all data to numpy arrays, reverse the direction of 
        # temperature so that the spline functions don't spit the dummy,
        # and convert values to decent ones
        for key, value in output_data.iteritems():
            output_data[key] = numpy.array(value)[::-1]
        self._convert_units(output_data)
        return dict(output_data)

    def read_phase_file(self, phase_file, translation, with_endmembers=False,
        with_composition=False):
        """ Function which stores the results of a MELTS calculation for a 
            particular phase. 

            Arguments:
                phase_file - A string containing a path to a MELTS data file.
                translation - A dictionary telling the function how to interpret the headings in the melts file. The keys are what get stored, the values correspond to the headings in the melts-liquid.tbl file output by MELTS. Interpolations will be generated as methods with the same name as the translation, with spaces replaced by underscores
                with_endmembers - If this flag is set, the function will attempt to add information about the endmember makeup of the given phase automatically from the file.
                with_composition - if this flag is set, the function will attempt to generate a list of pymelts.Composition instances for each entry in the phase file.
            
            Returns:
                A dict of data, where each dict value is a numpy array of values organised by entry in the input file.
        """

        # Get endmember keys and add to translation dict if required
        if with_endmembers:
            # Get list of header labels (will be first line in file)
            with file(phase_file, 'rb') as fhandle:
                headers = map(lambda s: s.strip('\n'), 
                    fhandle.next().split(','))

            # Strip out 'Index' and everything with brackets or a percentage 
            # sign, what's left is an endmember fraction
            strip_re = re.compile('Index|.*[\(\)]+.*|.*wt\%.*')
            headers = filter(lambda x: not strip_re.match(x), headers)

            # Strip out whitespace etc for dictionary keys
            endmembers = map(lambda s: s.strip(), headers)
            translation.update(dict(zip(endmembers, headers)))

        # Read files into a csv reader
        phase_data = defaultdict(list)
        with file(phase_file, 'rb') as fhandle:
            for line in csv.DictReader(fhandle, restval=0): 
                phase_data['index'].append(int(line['Index']) - 1)
                for prop, header in translation.iteritems():
                    phase_data[prop].append(numpy.float(line[header]))

        # Get composition keys and add to properties dict if required
        # We need to do this seperately because each line should generate a 
        # new pymelts.Composition instance.
        if with_composition:
            # Get list of header labels
            with file(phase_file, 'rb') as fhandle:
                headers = map(lambda s: s.strip('\n'),
                    fhandle.next().split(','))

            # Composition headers look like 'wt% XnO'. Strip this to get the 
            # oxide name (which is the second bit after the space).
            filter_re = re.compile('\s*wt\%.*')
            headers = filter(lambda s: filter_re.match(s), headers)
            oxides = map(lambda s: s.split()[1], headers)

            # Loop through file and make a composition instance for each line
            with file(phase_file, 'rb') as fhandle:
                for line in csv.DictReader(fhandle, restval=0):
                    temp_dict = {}
                    for header, oxide in zip(headers, oxides):
                        temp_dict[oxide] = numpy.float(line[header])
                    phase_data['composition'].append(temp_dict)

        # Convert all data to numpy arrays, reverse the direction of 
        # temperature so that the spline functions don't spit the dummy
        # We also need to fix the indices since everything is swapped around
        for prop, value in phase_data.iteritems():
            phase_data[prop] = numpy.array(value)[::-1]
        phase_data['index'] = \
            len(self.system_data['temperature']) - 1 - phase_data['index']
        self._convert_units(phase_data)

        # Return the results
        if with_endmembers:
            phase_data['endmembers'] = endmembers
        return dict(phase_data) # Remove defaultdict behaviour

    def print_data(self, verbose=False):
        """ Pretty prints some information about the information stored in the instance of Reader.

            Arguments:
                verbose - if this flag is set, then the function will print the actual data values. If it is False (the default) then the function will only print the length of the arrays in the instance.

            Returns:
                A string of information.
        """
        # Print system information
        print '\nSystem :'
        for key, value in self.system_data.iteritems():
            print ' --', key,
            if verbose:
                print value
            else:
                print ': length = ', len(value)

        # Print information for each phase
        for phase, data in self.phase_data.iteritems():
            print '\n', phase, ':'
            for key, value in data.iteritems():
                print ' --', key,
                if verbose:
                    print data[key]
                else:
                    print ': length =', 
                    print len(data[key])

    # Internal methods
    def _convert_units(self, data):
        """ Convert values to decent units!! Note that this method will modify the values in the data array in place.

            Arguments:
                data - A dictionary of data values, given as numpy arrays
        """
        data['temperature'] += 273.15  # deg C -> K
        for key in data.keys():
            if 'density' in key:
                data[key] *= 1e3 # g/cm^3 -> kg/m^3
        if 'log viscosity' in data.keys():
            data['dynamic viscosity'] = \
                10 ** (data['log viscosity'] - 1)  # lg10(Poise) -> Pa s
            data['kinematic viscosity'] = \
                data['dynamic viscosity'] / data['density']
